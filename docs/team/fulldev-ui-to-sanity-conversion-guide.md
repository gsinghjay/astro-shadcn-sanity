# Converting fulldotdev/ui Blocks to Sanity CMS

**Date:** 2026-02-10
**Scope:** Stories 2.4, 2.5, 2.6, 2.7, 2.8 (102 blocks total)
**Prerequisite:** Story 2.9 (unified dispatch pattern) should be completed first

---

## Table of Contents

1. [Architecture Overview](#1-architecture-overview)
2. [The Core Challenge: Props Mapping](#2-the-core-challenge-props-mapping)
3. [Step-by-Step Process Per Block](#3-step-by-step-process-per-block)
4. [Walkthrough: `hero-1` (Simple)](#4-walkthrough-hero-1-simple)
5. [Walkthrough: `features-1` (Nested Arrays)](#5-walkthrough-features-1-nested-arrays)
6. [Walkthrough: `logos-1` (Images)](#6-walkthrough-logos-1-images)
7. [Common Prop Patterns & Schema Mappings](#7-common-prop-patterns--schema-mappings)
8. [GROQ Projection Patterns](#8-groq-projection-patterns)
9. [TypeGen Integration](#9-typegen-integration)
10. [Files Touched Per Block](#10-files-touched-per-block)
11. [Block Inventory by Story](#11-block-inventory-by-story)
12. [Pitfalls & Gotchas](#12-pitfalls--gotchas)

---

## 1. Architecture Overview

### Current State

The fulldotdev/ui blocks are **static Astro components** with hardcoded demo data in Storybook stories. They receive flat props via spread:

```astro
<!-- BlockRenderer.astro -->
<FdComponent {...(block as any)} />
```

They are NOT connected to Sanity. Content editors cannot add or edit them in Studio.

### Target State

Each fulldotdev/ui block gets:
1. A **Sanity schema** (using `defineBlock`) so editors can add it in Studio
2. A **GROQ projection** so the query returns the right data shape
3. **TypeScript types** generated by TypeGen (no manual types)
4. **No changes to the `.astro` component** — the GROQ projection reshapes Sanity data to match the component's existing props

### Key Principle

**The GROQ projection is the adapter layer.** The component's Props interface is the contract. The schema models the data in Sanity's way (references, image assets, portable text). The GROQ projection transforms Sanity's data shape into the component's expected props shape.

```
┌──────────────┐     ┌──────────────────┐     ┌──────────────────┐
│ Sanity Schema │ --> │ GROQ Projection  │ --> │ Component Props  │
│ (structured)  │     │ (adapter/reshape) │     │ (flat, simple)   │
└──────────────┘     └──────────────────┘     └──────────────────┘
```

---

## 2. The Core Challenge: Props Mapping

### fulldotdev/ui components expect flat, simple data:

```typescript
// What hero-1.astro expects
interface Props {
  class?: string
  id?: string
  link?: { text?: string; href?: string; icon?: string; target?: string }
  links?: { text?: string; href?: string; icon?: string; target?: string }[]
  image?: { src: string; alt: string }  // <-- Simple string URL!
}
```

### Sanity stores structured content:

```typescript
// What Sanity stores
{
  image: {
    asset: { _ref: "image-abc123-800x600-png" },  // Reference to asset
    hotspot: { x: 0.5, y: 0.5 },
    alt: "Hero image"
  }
}
```

### The GROQ projection bridges the gap:

```groq
_type == "hero-1" => {
  link,
  links,
  image {
    "src": asset->url,   // Resolves reference to a URL string
    alt
  }
}
```

This is the fundamental pattern for every block conversion.

---

## 3. Step-by-Step Process Per Block

For each of the 102 blocks, follow these 7 steps:

### Step 1: Read the component props

Open the `.astro` file and extract the `Props` interface. Document every field, its type, and whether it's required.

### Step 2: Create the Sanity schema

Create `studio/src/schemaTypes/blocks/{block-name}.ts` using `defineBlock`. Map each component prop to the appropriate Sanity field type:

| Component Prop Type | Sanity Field Type |
|---------------------|-------------------|
| `string` | `string` |
| `string` (multiline) | `text` |
| `number` | `number` |
| `boolean` | `boolean` |
| `string[]` | `array` of `string` |
| `{ src: string; alt: string }` | `image` with `hotspot: true` + `alt` field |
| `{ text; href; icon; target }` | `object` (link object) |
| `{ title; description }[]` | `array` of `object` |
| `{ title; description; list: string[] }[]` | `array` of `object` with nested `array` |
| Nested `images[]` | `array` of `image` |

### Step 3: Register the schema

Add the import and export to `studio/src/schemaTypes/index.ts`.

### Step 4: Add to page schema

Add `defineArrayMember({ type: 'block-name' })` to the `blocks[]` array in `studio/src/schemaTypes/documents/page.ts`.

### Step 5: Add GROQ projection

Add a type-conditional projection to `PAGE_BY_SLUG_QUERY` in `astro-app/src/lib/sanity.ts`. This is where you reshape Sanity's structured data into the component's expected props shape.

### Step 6: Run TypeGen

```bash
npm run typegen
```

This regenerates `astro-app/src/sanity.types.ts` with the new query result types.

### Step 7: Add type export to types.ts

Add the `Extract<>` type to `astro-app/src/lib/types.ts` and include it in the `PageBlock` union.

---

## 4. Walkthrough: `hero-1` (Simple)

### Step 1: Read the component

```typescript
// astro-app/src/components/blocks/hero-1.astro
interface Props {
  class?: string
  id?: string
  link?: { text?: string; href?: string; icon?: string; target?: string }
  links?: { text?: string; href?: string; icon?: string; target?: string }[]
  image?: { src: string; alt: string }
}
```

### Step 2: Create the schema

```typescript
// studio/src/schemaTypes/blocks/hero-1.ts
import {defineField, defineArrayMember} from 'sanity'
import {ImageIcon} from '@sanity/icons'
import {defineBlock} from '../helpers/defineBlock'

export const hero1 = defineBlock({
  name: 'hero-1',
  title: 'Hero 1',
  icon: ImageIcon,
  preview: {select: {title: 'link.text'}},
  fields: [
    defineField({
      name: 'link',
      title: 'Badge Link',
      type: 'object',
      fields: [
        defineField({name: 'text', type: 'string', title: 'Text'}),
        defineField({name: 'href', type: 'string', title: 'URL'}),
        defineField({name: 'icon', type: 'string', title: 'Icon Name'}),
        defineField({
          name: 'target',
          type: 'string',
          title: 'Target',
          options: {list: ['_self', '_blank']},
        }),
      ],
    }),
    defineField({
      name: 'links',
      title: 'Action Buttons',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          fields: [
            defineField({name: 'text', type: 'string', title: 'Text'}),
            defineField({name: 'href', type: 'string', title: 'URL'}),
            defineField({name: 'icon', type: 'string', title: 'Icon Name'}),
            defineField({
              name: 'target',
              type: 'string',
              title: 'Target',
              options: {list: ['_self', '_blank']},
            }),
          ],
          preview: {select: {title: 'text', subtitle: 'href'}},
        }),
      ],
    }),
    defineField({
      name: 'image',
      title: 'Image',
      type: 'image',
      options: {hotspot: true},
      fields: [
        defineField({
          name: 'alt',
          type: 'string',
          title: 'Alt Text',
          validation: (Rule) => Rule.required(),
        }),
      ],
    }),
  ],
})
```

### Step 3: Register

```typescript
// studio/src/schemaTypes/index.ts
import {hero1} from './blocks/hero-1'

export const schemaTypes: SchemaTypeDefinition[] = [
  // ...existing schemas
  hero1,
]
```

### Step 4: Add to page blocks

```typescript
// studio/src/schemaTypes/documents/page.ts — in blocks[] array
defineArrayMember({type: 'hero-1'}),
```

### Step 5: GROQ projection

```groq
_type == "hero-1" => {
  link,
  links[]{ _key, text, href, icon, target },
  image {
    "src": asset->url,
    alt
  }
}
```

**Key transformation:** `image.asset->url` becomes `image.src` — matching what the component expects.

### Step 6: Run TypeGen

```bash
npm run typegen
```

### Step 7: Add to types.ts

```typescript
// astro-app/src/lib/types.ts
export type Hero1Block = Extract<PageBlock, { _type: 'hero-1' }>;
// Add Hero1Block to PageBlock union
```

---

## 5. Walkthrough: `features-1` (Nested Arrays)

### Component Props

```typescript
interface Props {
  class?: string
  id?: string
  links?: { icon?: string; text?: string; href?: string; target?: string }[]
  items?: {
    title?: string
    description?: string
    icon?: string
    href?: string
    links?: { icon?: string; text?: string; href?: string; target?: string }[]
  }[]
}
```

### Schema (key parts)

```typescript
export const features1 = defineBlock({
  name: 'features-1',
  title: 'Features 1',
  icon: BlockContentIcon,
  preview: {select: {title: 'items.0.title'}},
  fields: [
    defineField({
      name: 'links',
      title: 'Action Links',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          fields: [
            defineField({name: 'icon', type: 'string', title: 'Icon'}),
            defineField({name: 'text', type: 'string', title: 'Text'}),
            defineField({name: 'href', type: 'string', title: 'URL'}),
            defineField({name: 'target', type: 'string', title: 'Target'}),
          ],
          preview: {select: {title: 'text'}},
        }),
      ],
    }),
    defineField({
      name: 'items',
      title: 'Feature Items',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          fields: [
            defineField({name: 'title', type: 'string', title: 'Title'}),
            defineField({name: 'description', type: 'text', title: 'Description'}),
            defineField({name: 'icon', type: 'string', title: 'Icon Name'}),
            defineField({name: 'href', type: 'string', title: 'Link URL'}),
            defineField({
              name: 'links',
              title: 'Item Links',
              type: 'array',
              of: [
                defineArrayMember({
                  type: 'object',
                  fields: [
                    defineField({name: 'icon', type: 'string', title: 'Icon'}),
                    defineField({name: 'text', type: 'string', title: 'Text'}),
                    defineField({name: 'href', type: 'string', title: 'URL'}),
                    defineField({name: 'target', type: 'string', title: 'Target'}),
                  ],
                  preview: {select: {title: 'text'}},
                }),
              ],
            }),
          ],
          preview: {select: {title: 'title', subtitle: 'description'}},
        }),
      ],
    }),
  ],
})
```

### GROQ Projection

No image transformations needed here — all fields are simple strings. The projection is straightforward:

```groq
_type == "features-1" => {
  links[]{ _key, icon, text, href, target },
  items[]{ _key, title, description, icon, href,
    links[]{ _key, icon, text, href, target }
  }
}
```

---

## 6. Walkthrough: `logos-1` (Images)

### Component Props

```typescript
interface Props {
  class?: string
  id?: string
  logos?: {
    src: string   // Required URL string
    alt: string   // Required alt text
    text?: string
    href?: string
  }[]
}
```

### Schema

```typescript
export const logos1 = defineBlock({
  name: 'logos-1',
  title: 'Logos 1',
  icon: ImageIcon,
  preview: {select: {title: 'logos.0.text'}},
  fields: [
    defineField({
      name: 'logos',
      title: 'Logos',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          fields: [
            defineField({
              name: 'image',
              title: 'Logo Image',
              type: 'image',
              options: {hotspot: true},
              validation: (Rule) => Rule.required(),
              fields: [
                defineField({
                  name: 'alt',
                  type: 'string',
                  title: 'Alt Text',
                  validation: (Rule) => Rule.required(),
                }),
              ],
            }),
            defineField({name: 'text', type: 'string', title: 'Logo Text'}),
            defineField({name: 'href', type: 'string', title: 'Link URL'}),
          ],
          preview: {select: {title: 'text', media: 'image'}},
        }),
      ],
    }),
  ],
})
```

### GROQ Projection (critical reshaping)

The component expects `{ src, alt }` but Sanity stores `{ image: { asset, alt } }`. The GROQ projection reshapes:

```groq
_type == "logos-1" => {
  logos[]{
    _key,
    "src": image.asset->url,
    "alt": image.alt,
    text,
    href
  }
}
```

**What's happening:**
- `"src": image.asset->url` — resolves the asset reference to a URL and renames it to `src`
- `"alt": image.alt` — pulls alt from the image's custom field and hoists it to the top level
- The component receives `{ src: "https://cdn...", alt: "Logo", text: "Acme", href: "/partners/acme" }` — exactly matching its Props

---

## 7. Common Prop Patterns & Schema Mappings

### Pattern A: Link Object

Almost every fulldotdev/ui component uses this pattern:

```typescript
// Component expects:
links?: { icon?: string; text?: string; href?: string; target?: string }[]
```

**Reusable shared object (recommended):** Create a shared link object type to avoid duplication across 100+ schemas.

```typescript
// studio/src/schemaTypes/objects/fd-link.ts
import {defineType, defineField} from 'sanity'

export const fdLink = defineType({
  name: 'fdLink',
  title: 'Link',
  type: 'object',
  fields: [
    defineField({name: 'text', type: 'string', title: 'Text'}),
    defineField({name: 'href', type: 'string', title: 'URL'}),
    defineField({name: 'icon', type: 'string', title: 'Icon Name',
      description: 'Lucide icon name (e.g., "arrow-right", "check")'}),
    defineField({name: 'target', type: 'string', title: 'Target',
      options: {list: ['_self', '_blank']}}),
  ],
  preview: {select: {title: 'text', subtitle: 'href'}},
})
```

Then use it in schemas:

```typescript
defineField({
  name: 'links',
  type: 'array',
  of: [defineArrayMember({type: 'fdLink'})],
})
```

And in GROQ (no transformation needed — field names match):

```groq
links[]{ _key, text, href, icon, target }
```

### Pattern B: Simple Image

```typescript
// Component expects:
image?: { src: string; alt: string }
```

**Schema:**

```typescript
defineField({
  name: 'image',
  type: 'image',
  options: {hotspot: true},
  fields: [
    defineField({name: 'alt', type: 'string', title: 'Alt Text',
      validation: (Rule) => Rule.required()}),
  ],
})
```

**GROQ:**

```groq
image {
  "src": asset->url,
  alt
}
```

### Pattern C: Image Array

```typescript
// Component expects:
images?: { src: string; alt: string }[]
```

**GROQ:**

```groq
images[]{
  _key,
  "src": asset->url,
  alt
}
```

### Pattern D: Item with Nested Image

```typescript
// Component expects:
item?: {
  images?: { src: string; alt: string }[]
  rating?: number
  description?: string
}
```

**Schema:**

```typescript
defineField({
  name: 'item',
  type: 'object',
  fields: [
    defineField({
      name: 'images', type: 'array',
      of: [defineArrayMember({
        type: 'image', options: {hotspot: true},
        fields: [defineField({name: 'alt', type: 'string', title: 'Alt Text'})],
      })],
    }),
    defineField({name: 'rating', type: 'number', title: 'Rating'}),
    defineField({name: 'description', type: 'string', title: 'Description'}),
  ],
})
```

**GROQ:**

```groq
item {
  images[]{ _key, "src": asset->url, alt },
  rating,
  description
}
```

### Pattern E: Simple Items Array

```typescript
// Component expects:
items?: { title?: string; description?: string }[]
```

**Schema:**

```typescript
defineField({
  name: 'items',
  type: 'array',
  of: [defineArrayMember({
    type: 'object',
    fields: [
      defineField({name: 'title', type: 'string', title: 'Title'}),
      defineField({name: 'description', type: 'text', title: 'Description'}),
    ],
    preview: {select: {title: 'title', subtitle: 'description'}},
  })],
})
```

**GROQ:**

```groq
items[]{ _key, title, description }
```

### Pattern F: Items with Nested List

```typescript
// Component expects:
items?: { title?: string; description?: string; list?: string[] }[]
```

**Schema:**

```typescript
defineField({
  name: 'items',
  type: 'array',
  of: [defineArrayMember({
    type: 'object',
    fields: [
      defineField({name: 'title', type: 'string', title: 'Title'}),
      defineField({name: 'description', type: 'text', title: 'Description'}),
      defineField({name: 'list', type: 'array', title: 'List Items',
        of: [defineArrayMember({type: 'string'})]}),
    ],
    preview: {select: {title: 'title'}},
  })],
})
```

**GROQ:**

```groq
items[]{ _key, title, description, list }
```

### Pattern G: Logo Object (in header/footer)

```typescript
// Component expects:
logo?: { src?: string; alt?: string; text?: string; href?: string }
```

**Schema:**

```typescript
defineField({
  name: 'logo',
  type: 'object',
  fields: [
    defineField({
      name: 'image', type: 'image', title: 'Logo Image',
      options: {hotspot: true},
      fields: [defineField({name: 'alt', type: 'string', title: 'Alt Text'})],
    }),
    defineField({name: 'text', type: 'string', title: 'Logo Text'}),
    defineField({name: 'href', type: 'string', title: 'Link URL'}),
  ],
})
```

**GROQ:**

```groq
logo {
  "src": image.asset->url,
  "alt": image.alt,
  text,
  href
}
```

### Pattern H: Menus with Nested Links

```typescript
// Component expects:
menus?: {
  text?: string; href?: string;
  links?: { text?: string; href?: string }[]
}[]
```

**Schema:**

```typescript
defineField({
  name: 'menus',
  type: 'array',
  of: [defineArrayMember({
    type: 'object',
    fields: [
      defineField({name: 'text', type: 'string', title: 'Menu Title'}),
      defineField({name: 'href', type: 'string', title: 'URL'}),
      defineField({
        name: 'links', type: 'array', title: 'Sub-links',
        of: [defineArrayMember({
          type: 'object',
          fields: [
            defineField({name: 'text', type: 'string', title: 'Text'}),
            defineField({name: 'href', type: 'string', title: 'URL'}),
          ],
          preview: {select: {title: 'text'}},
        })],
      }),
    ],
    preview: {select: {title: 'text'}},
  })],
})
```

**GROQ:**

```groq
menus[]{ _key, text, href, links[]{ _key, text, href } }
```

### Pattern I: Socials (URL string array)

```typescript
// Component expects:
socials?: string[]  // Array of URLs like "https://github.com/..."
```

**Schema:**

```typescript
defineField({
  name: 'socials',
  type: 'array',
  title: 'Social Links',
  of: [defineArrayMember({type: 'url'})],
})
```

**GROQ:**

```groq
socials
```

---

## 8. GROQ Projection Patterns

### Where projections go

All projections are added to `PAGE_BY_SLUG_QUERY` in `astro-app/src/lib/sanity.ts`, inside the `blocks[]` array:

```groq
blocks[]{
  _type,
  _key,
  backgroundVariant,
  spacing,
  maxWidth,

  // Existing custom block projections...
  _type == "heroBanner" => { ... },

  // NEW fulldotdev/ui block projections
  _type == "hero-1" => {
    link,
    links[]{ _key, text, href, icon, target },
    image { "src": asset->url, alt }
  },
  _type == "hero-2" => {
    links[]{ _key, text, href, icon, target },
    image { "src": asset->url, alt },
    item {
      images[]{ _key, "src": asset->url, alt },
      rating,
      description
    }
  },
  // ... 100 more projections
}
```

### Projection for blocks with no images (simple)

Many blocks (features, stats, steps, links, cta variants) have no images. Their projections are trivial:

```groq
_type == "stats-1" => {
  links[]{ _key, icon, text, href, target },
  items[]{ _key, title, description }
}
```

### Projection for blocks with images (must reshape)

```groq
_type == "content-1" => {
  list,
  links[]{ _key, icon, text, href, target },
  image { "src": asset->url, alt }
}
```

### Performance note

Adding 102 type-conditional projections to a single GROQ query is fine. GROQ evaluates only the matching `_type ==` branch, so unused projections have zero cost.

---

## 9. TypeGen Integration

### After adding schemas and projections, run:

```bash
npm run typegen
# Which runs: sanity schema extract --path=schema.json && sanity typegen generate
```

### TypeGen generates result types automatically

For a query like:

```groq
_type == "hero-1" => {
  link,
  links[]{ _key, text, href, icon, target },
  image { "src": asset->url, alt }
}
```

TypeGen produces (in `sanity.types.ts`):

```typescript
// Auto-generated — DO NOT manually type this
{
  _type: "hero-1"
  _key: string
  backgroundVariant?: "white" | "light" | "dark" | "primary"
  spacing?: "none" | "small" | "default" | "large"
  maxWidth?: "narrow" | "default" | "full"
  link?: { text?: string; href?: string; icon?: string; target?: string } | null
  links?: Array<{ _key: string; text?: string; href?: string; icon?: string; target?: string }> | null
  image?: { src: string; alt?: string } | null
}
```

### Then extract types in `types.ts`:

```typescript
// astro-app/src/lib/types.ts
export type Hero1Block = Extract<PageBlock, { _type: 'hero-1' }>;
```

**Do NOT manually write interfaces.** TypeGen generates them from the GROQ query + schema.

---

## 10. Files Touched Per Block

Every block conversion touches exactly **4 files** (plus generated files):

| # | File | Action |
|---|------|--------|
| 1 | `studio/src/schemaTypes/blocks/{name}.ts` | **Create** schema file |
| 2 | `studio/src/schemaTypes/index.ts` | **Add** import + registration |
| 3 | `studio/src/schemaTypes/documents/page.ts` | **Add** `defineArrayMember` to `blocks[]` |
| 4 | `astro-app/src/lib/sanity.ts` | **Add** GROQ projection |

After all blocks in a story are done:

| # | File | Action |
|---|------|--------|
| 5 | `astro-app/src/sanity.types.ts` | **Generated** by `npm run typegen` |
| 6 | `astro-app/src/lib/types.ts` | **Add** `Extract<>` types + update `PageBlock` union |

**No changes to `.astro` component files.** The components are already written and working.

---

## 11. Block Inventory by Story

### Story 2.4: Hero & Banner (22 blocks)

| Block | Key Props | Image Handling |
|-------|-----------|----------------|
| hero-1 | link, links[], image | Single `{ src, alt }` |
| hero-2 | links[], image, item.images[] | Main image + avatar array |
| hero-3 | links[], image | Single image |
| hero-4 | links[], image | Single image |
| hero-5 | list[], links[], image, item.images[] | Main image + avatars |
| hero-6 | links[], image | Single image |
| hero-7 | links[], image | Single image |
| hero-8 | links[], image | Single image |
| hero-9 | links[], images[] | Image array |
| hero-10 | links[], image, item.images[] | Background image + avatars |
| hero-11 | links[], images[] | Image array |
| hero-12 | links[], images[] | Image array |
| hero-13 | links[], images[] | Image array |
| hero-14 | links[], image | Single image |
| banner-1 | icon, title, description | None |
| banner-2 | icon, title, description | None |
| header-1 | logo, links[], socials[], menus[] | Logo image |
| header-2 | logo, links[], socials[], menus[] | Logo image |
| header-3 | logo, links[], socials[], menus[] | Logo image |
| footer-1 | logo, description, socials[], menus[], links[] | Logo image |
| footer-2 | logo, description, socials[], menus[], links[] | Logo image |
| footer-3 | logo, description, socials[], menus[], links[] | Logo image |

### Story 2.5: Content & Articles (19 blocks)

| Block | Key Props | Image Handling |
|-------|-----------|----------------|
| content-1 to 6 | list[], links[], image | Single image |
| article-1, 2 | links[], items[].image | Article images |
| articles-1 to 4 | links[], items[].image, items[].item.image | Article + author images |
| blocks-1 to 4 | Varies (meta-blocks) | Mixed |
| links-1, 2 | links[] | None |
| table-1 | list[], links[], items[] | None |

### Story 2.6: CTA & Features (21 blocks)

| Block | Key Props | Image Handling |
|-------|-----------|----------------|
| cta-1 to 8 | links[], item.images[] | Avatar images (some) |
| features-1 to 6 | links[], items[].icon | Icons only (no images) |
| steps-1 to 3 | links[], items[].list[] | None |
| faqs-1 to 4 | items[].title/description | None |

### Story 2.7: Products & Services (21 blocks)

| Block | Key Props | Image Handling |
|-------|-----------|----------------|
| product-1 | links[], items[].image | Product images |
| products-1 to 5 | links[], items[].image | Product images |
| services-1 to 7 | links[], items[] | Icons or none |
| pricings-1 to 3 | links[], items[].list[] | None |
| reviews-1 to 5 | items[].image, items[].rating | Avatar images |

### Story 2.8: Media & Misc (19 blocks)

| Block | Key Props | Image Handling |
|-------|-----------|----------------|
| logos-1 to 3 | logos[].src/alt | Logo images |
| images-1, 2 | items[].image | Gallery images |
| video-1 to 3 | image (poster), src (video URL) | Poster image |
| videos-1 to 4 | items[].image (poster) | Poster images |
| contact-1 to 3 | form, items[] | None |
| stats-1 to 3 | items[] | None |
| skeletons-1 | — | None |

---

## 12. Pitfalls & Gotchas

### 1. Schema names must match `_type` in BlockRenderer

The `fulldotdevBlocks` map in `BlockRenderer.astro` uses the block `_type` as the key:

```typescript
const fulldotdevBlocks: Record<string, any> = {
  'hero-1': Hero1,  // The schema name 'hero-1' must match this key exactly
  // ...
}
```

Your schema `name` field must be exactly `'hero-1'`, not `'hero1'` or `'Hero1'`.

### 2. `defineBlock` auto-prepends base fields

The `defineBlock` helper automatically adds `backgroundVariant`, `spacing`, and `maxWidth` fields. The GROQ query already projects these at the top level of `blocks[]`:

```groq
blocks[]{
  _type, _key,
  backgroundVariant, spacing, maxWidth,  // <-- Already projected for ALL blocks
  ...
}
```

So your per-block projection does NOT need to include these.

### 3. Images need `"src": asset->url` transformation

The component expects `image.src` (string). Sanity stores `image.asset._ref`. You MUST use `"src": asset->url` in your GROQ projection. Forgetting this is the #1 cause of broken images.

### 4. Array items need `_key` in GROQ projections

Always include `_key` when projecting array items. Without it, Visual Editing overlays and React reconciliation break:

```groq
// Good
items[]{ _key, title, description }

// Bad — missing _key
items[]{ title, description }
```

### 5. `slot` content cannot be stored in Sanity

Many fulldotdev/ui components use `<slot />` for rich text content (headings, paragraphs). Slots are HTML rendered by Astro at build time — they can't come from Sanity directly.

**Options:**
1. **Use Portable Text** — Add a `content` field of type `portableText` and render it where the slot would go. This requires modifying the component to accept a `content` prop as an alternative to `<slot />`.
2. **Use string fields** — Add `heading` and `description` string fields. Simpler but less flexible.
3. **Ignore slots** — Leave slot content empty. The Sanity-managed fields (`links`, `items`, etc.) still work.

**Recommendation:** For the initial conversion, use string fields (`heading`, `description`) mapped from simple Sanity text fields. Add Portable Text support later if needed.

### 6. `form` prop in contact blocks

Some contact blocks accept a `form` prop that drives an auto-generated form. This is complex to model in Sanity. Consider:
- Hardcoding the form structure in the component
- Using a simple array of field definitions in Sanity
- Skipping form-heavy blocks initially

### 7. `blocks-1` through `blocks-4` are meta-blocks

These components render other blocks inside themselves. They accept `[key: string]: any` — essentially a passthrough. These may not need Sanity schemas at all since they're development/demo tools.

### 8. Run TypeGen after ALL blocks in a story are done

Don't run TypeGen after each individual block. Wait until all blocks in a story are added, then run once:

```bash
npm run typegen
```

This is faster and avoids intermediate broken type states.

### 9. Insert menu groups

When adding 100+ blocks to the page schema, organize them into `insertMenu.groups`:

```typescript
options: {
  insertMenu: {
    filter: true,
    groups: [
      // Existing groups...
      {name: 'fd-heroes', title: 'Hero Variants', of: ['hero-1', 'hero-2', ...]},
      {name: 'fd-content', title: 'Content Variants', of: ['content-1', ...]},
      {name: 'fd-cta', title: 'CTA Variants', of: ['cta-1', ...]},
      // etc.
    ],
  },
}
```

### 10. Consider creating shared object types

With 102 blocks, you'll define the same `{ text, href, icon, target }` link object 100+ times. Extract shared types:

- `fdLink` — Standard link/button object
- `fdImage` — Image with src/alt (use Sanity image type)
- `fdItem` — Title/description pair
- `fdItemWithImage` — Title/description + image

This dramatically reduces schema boilerplate and ensures consistency.
